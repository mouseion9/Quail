(defun draw-inside-rectangle (canvas left &optional top right bot)
   "Draws a specified box no longer worrying about ~
Inside but compatible with fast-macros."
  (let ((mp (clim-user::get-frame-pane canvas 'display)))
   (cond ((numberp bot)  
           (format t "~% bot=number: l t r b as input ~d ~d ~d ~d ~%" left top right bot)
          (let* ((mx (truncate (+ left right) 2))
                  (my (truncate (+ top bot ) 2))
                  (sh (truncate (- right left) 2))
                  (sv (truncate (- bot top) 2))
                  (lhs (- mx sh))
                  (rhs (+ lhs (- right left)))
                  (ths (if (oddp (- bot top)) (- my sv -1) (- my sv)))
                  (bhs (+ ths (- bot top))))
              ;(if (= 1 (- rhs lhs))
                (format t "~% bot=number l t r b used ~d ~d ~d ~d ~%" lhs ths rhs bhs)
                  ;(clim-user::draw-point* mp lhs ths :ink clim-user::+black+)
                  ;(clim-user::draw-rectangle* mp lhs ths rhs bhs :filled NIL))
              ))
         ((equal (type-of left) 'STANDARD-RECTANGLE)
          ;;; left is then a box which must be picked apart
          (let* ((lx (clim-user::rectangle-min-x left)) (rx (clim-user::rectangle-max-x left))
                 (ty (clim-user::rectangle-min-y left)) (by (clim-user::rectangle-max-y left))
                 (mx (truncate (+ lx rx) 2))
                 (my (truncate (+ ty by ) 2))
                 (sh (truncate (- rx lx) 2))
                 (sv (truncate (- by ty) 2))
                 (lhs (- mx sh))
                 (rhs (+ lhs (- rx lx)))
                 (ths (if (oddp (- by ty)) (- my sv -1) (- my sv)))
                 (bhs (+ ths (- by ty))))
          (format t "~% left=rectangle: l t r b as input ~d ~d ~d ~d ~%" lx ty rx by)
          (format t "~% left=rectangle: l t r b as input ~d ~d ~d ~d ~%" lhs ths rhs bhs)
             ;(if (= 1 (- rhs lhs))
                ;(clim-user::draw-point* mp lhs ths :ink clim-user::+black+)
                ;(clim-user::draw-rectangle* mp lhs ths rhs bhs :filled NIL))
             ))
         ((equal (type-of top) 'STANDARD-POINT)
          ;;; top is a position and thus so is left. left is top-left  top is bottom-right
          (let* ((lx (clim-user::point-x left)) (rx (clim-user::point-x top))
                 (ty (clim-user::point-y left)) (by (clim-user::point-y top))
                 (mx (truncate (+ lx rx) 2))
                 (my (truncate (+ ty by ) 2))
                 (sh (truncate (- rx lx) 2))
                 (sv (truncate (- by ty) 2))
                 (lhs (- mx sh))
                 (rhs (+ lhs (- rx lx)))
                 (ths (if (oddp (- by ty)) (- my sv -1) (- my sv)))
                 (bhs (+ ths (- by ty))))
          (format t "~% top=point: l t r b as input ~d ~d ~d ~d ~%" lx tx rx bx)
          (format t "~% top=point: l t r b as input ~d ~d ~d ~d ~%" lhs ths rhs bhs)
             ;(if (= 1 (- rhs lhs))  ;;02nov99
                ;(clim-user::draw-point* mp lhs ths :ink clim-user::+black+)
                ;(clim-user::draw-rectangle* mp lhs ths rhs bhs :filled NIL))
                ))           
         ((equal (type-of right) 'STANDARD-POINT)
          ;;; left *is* left, top *is* top, right *is* position(bottom-right)
          (let* ((lx left) (rx (clim-user::point-x right)) (ty top)
                 (by (clim-user::point-y right))
                 (mx (truncate (+ lx rx) 2))
                 (my (truncate (+ ty by ) 2))
                 (sh (truncate (- rx lx) 2))
                 (sv (truncate (- by ty) 2))
                 (lhs (- mx sh))
                 (rhs (+ lhs (- rx lx)))
                 (ths (if (oddp (- by ty)) (- my sv -1) (- my sv)))
                 (bhs (+ ths (- by ty))))
          (format t "~% right=point: l t r b as input ~d ~d ~d ~d ~%" lx tx rx bx)
          (format t "~% right=point: l t r b as input ~d ~d ~d ~d ~%" lhs ths rhs bhs)
             ;(if (= 1 (- rhs lhs)) ;;02nov99
                ;(clim-user::draw-point* mp lhs ths rhs bhs :ink clim-user::+black+)
                ;(clim-user::draw-rectangle* mp lhs ths rhs bhs :filled NIL))
                )) 
         #|
         (t 
           ;;; all four arguments are what they say they are
           (let* ((mx (truncate (+ left right) 2))
                  (my (truncate (+ top bot ) 2))
                  (sh (truncate (- right left) 2))
                  (sv (truncate (- bot top) 2))
                  (lhs (- mx sh))
                  (rhs (+ lhs (- right left)))
                  (ths (if (oddp (- bot top)) (- my sv -1) (- my sv))) ;<**
                  (bhs (+ ths (- bot top))))
              (if (= 1 (- rhs lhs)) ;;02nov99
                 (setf (cg::pixel-x-y mp lhs ths) cg::black) ;;02nov99
                  (cg::draw-box mp (cg::make-box lhs ths rhs bhs)))
              ))|#
         )))
